<?xml version="1.0" encoding="UTF-8"?>
<Prompts>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt1</Id>
        <Title>Explain Selected Query</Title>
        <Description>Explains complex logic. Breaks down the query execution flow.</Description>
        <Text>**Role**
You are an expert SQL instructor.

**Task**
- Explain the SQL query step-by-step for dialect `{{dialect}}`.
- Break down joins, filters, and aggregations.
- Infer the business intent (what question the query answers).

**Constraints**
- Use simple, non-technical language where possible.
- Do not invent schema details; if something is ambiguous, state assumptions.
- Keep the explanation accurate to the query as written.

**Response**
- Provide, in order:
1) One-paragraph plain-English summary
2) Step-by-step explanation (bullets or numbered list)
3) Business intent (1–2 sentences)
4) Notes on joins/filters/aggregations

**Query**
```sql
{{selected_sql}}
```</Text>
        <Placeholders>
            <Placeholder name="selected_sql"/>
            <Placeholder name="dialect" editable="true"/>
        </Placeholders>
        <Metadata>
            <Category>Refactor</Category>
        </Metadata>
    </Prompt>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt2</Id>
        <Title>Optimize and Analyze Performance</Title>
        <Description>Detailed performance suggestions</Description>
        <Text>**Role**
You are a Senior Database Performance Engineer.

**Task**
- Analyze the SQL query for performance bottlenecks in dialect `{{dialect}}`.
- Identify inefficient operations (e.g., full scans, non-sargable predicates, excessive sorting, correlated
subqueries, N+1-like patterns in SQL).
- Suggest specific indexes that could improve performance.
- Provide a refactored query that is more efficient.

**Constraints**
- Preserve semantics: the refactored query must return the same results.
- If schema/statistics are missing, clearly state assumptions and give conditional recommendations.
- Prefer safe, broadly applicable optimizations for the given dialect.

**Response**
- Provide, in order:
1) Bottlenecks found (bullets)
2) Recommendations (bullets, tied to specific query parts)
3) Refactored SQL
4) Short explanation of why the refactor is faster

**Query**
```sql
{{selected_sql}}
```</Text>
        <Placeholders>
            <Placeholder name="selected_sql"/>
            <Placeholder name="dialect" editable="true"/>
        </Placeholders>
        <Metadata>
            <Category>Refactor</Category>
        </Metadata>
    </Prompt>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt3</Id>
        <Title>Diagnose wrong / unexpected result</Title>
        <Description>Finds logical issues when the query runs but returns unexpected results (based on user
            description)
        </Description>
        <Text>**Role**
You are a Senior Database Administrator focused on query correctness.

**Task**
- Read the SQL query (dialect `{{dialect}}`) and the user's plain-language description of what seems wrong.
- Infer the most likely expected vs. actual behavior from the description.
- Identify likely logical causes in the SQL (joins, filters, grouping, NULL handling, DISTINCT, date
boundaries, aggregation levels, predicate placement, etc.).
- Propose a corrected version of the query that matches the likely intent.

**Constraints**
- Do not invent schema details. If the logic depends on unknown columns/keys/relationships, state
assumptions explicitly.
- Prefer minimal changes that preserve intent.
- If multiple interpretations are plausible, pick the best default and list 1–2 alternatives.
- If critical information is missing (e.g., “expected result”), ask up to 3 short clarifying questions, but
still provide the best-effort fix.

**Response**
- Provide, in order:
1) Your understanding: expected vs. actual (based on the description)
2) Likely cause(s) (bullets, tied to specific parts of the query)
3) Recommended fix (bullets)
4) Corrected SQL (single code block)
5) How to validate (2–5 quick checks / test queries)

**Query**
```sql
{{selected_sql}}

**Error Description**
{{error_message}}
```</Text>
        <Placeholders>
            <Placeholder name="selected_sql"/>
            <Placeholder name="dialect" editable="true"/>
            <Placeholder name="error_message" editable="true" rich="true"/>
        </Placeholders>
        <Metadata>
            <Category>Refactor</Category>
        </Metadata>
    </Prompt>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt4</Id>
        <Title>Convert SQL dialect</Title>
        <Description>Migrates code between systems (e.g. Access to PostgreSQL)</Description>
        <Text>**Role**
You are a SQL Migration Specialist.

**Task**
- Convert the SQL query from `{{source_dialect}}` to `{{target_dialect}}`.
- Adapt functions, quoting, date/time syntax, NULL handling, and dialect-specific clauses (e.g., LIMIT vs
TOP).
- Keep semantics equivalent.

**Constraints**
- The converted query must return the same results (as closely as the dialect allows).
- Avoid non-standard extensions unless needed for `{{target_dialect}}`.
- If something cannot be converted cleanly, explain the limitation and provide the closest workaround.

**Response**
- Provide, in order:
1) Converted SQL (single code block)
2) Key changes and compatibility notes (bullets)

**Original SQL**
```sql
{{selected_sql}}
```</Text>
        <Placeholders>
            <Placeholder name="selected_sql"/>
            <Placeholder name="source_dialect" editable="true"/>
            <Placeholder name="target_dialect" editable="true"/>
        </Placeholders>
        <Metadata>
            <Category>Refactor</Category>
        </Metadata>
    </Prompt>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt5</Id>
        <Title>Generate documentation</Title>
        <Description>Creates technical docs</Description>
        <Text>**Role**
You are a Technical Writer specializing in databases.

**Task**
- Generate technical documentation for the SQL query in `{{format}}` format.
- Assume SQL dialect `{{dialect}}`.

**Constraints**
- Include: a title, description of the logic, list of input parameters, and a summary of the tables
involved.
- Do not invent unknown schema details; if something is unclear, note assumptions.
- Keep the documentation focused on what can be inferred from the query text.

**Response**
- Output strictly in `{{format}}` format (no extra commentary outside the requested format).
- Include the required sections and keep them clearly labeled.

**Query**
```sql
{{selected_sql}}
```</Text>
        <Placeholders>
            <Placeholder name="selected_sql"/>
            <Placeholder name="dialect" editable="true"/>
            <Placeholder name="format" editable="true"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt6</Id>
        <Title>Generate Table from description</Title>
        <Description>Writes CREATE TABLE SQL based on natural language requirements</Description>
        <Text>**Role**
You are a Database Architect.

**Task**
- Write a valid `CREATE TABLE` statement that fulfills the requirement below.
- Target SQL dialect: `{{target_dialect}}`.

**Constraints**
- Include a primary key.
- Choose appropriate data types for the target dialect.
- Include constraints where reasonable (NOT NULL, UNIQUE, CHECK, FK if specified).
- If requirements are incomplete, make conservative defaults and list assumptions.

**Response**
- Provide, in order:
1) `CREATE TABLE` SQL (single code block)
2) Assumptions (bullets)
3) Optional: follow-up questions if critical details are missing

**Requirement**
```text
{{user_input}}
```</Text>
        <Placeholders>
            <Placeholder name="target_dialect" editable="true"/>
            <Placeholder name="user_input" editable="true" rich="true"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt7</Id>
        <Title>Generate SQL Query from description</Title>
        <Description>Translates a natural-language requirement into a SQL query</Description>
        <Text>**Role**
You are a SQL Query Generator.

**Task**
- Translate the user’s requirement into a SQL query for dialect `{{dialect}}`.
- Include appropriate SELECT list, FROM sources, JOINs, WHERE filters, GROUP BY / HAVING (if needed), ORDER
BY, and LIMIT/TOP (if requested).
- If the requirement implies parameters (date range, customer id, etc.), represent them as named parameters
(e.g., `:start_date`) or clearly marked placeholders.

**Constraints**
- Infer schema minimally. Do not invent tables/columns unless the user provides them.
- If the schema is missing, choose a reasonable generic schema *only* as an example, and clearly label it as
an assumption.
- Ask up to 5 clarifying questions *only if* the requirement is ambiguous in ways that materially change the
query.
- Prefer simple, correct SQL over clever/engine-specific tricks unless the dialect requires it.

**Response**
- Provide, in order:
1) Generated SQL (single code block)
2) Explanation of how the query satisfies the requirement (bullets)
3) Assumptions (bullets)
4) Clarifying questions (only if needed)

**User Requirement**
```text
{{user_input}}
```</Text>
        <Placeholders>
            <Placeholder name="dialect" editable="true"/>
            <Placeholder name="user_input" editable="true" rich="true"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="LlmPrompt">
        <Id>DefaultPrompt8</Id>
        <Title>Compare two SQL queries</Title>
        <Description>Compares logic, result equivalence, and performance characteristics</Description>
        <Text>**Role**
You are a SQL Comparator.

**Task**
- Compare Query A and Query B for dialect `{{target_dialect}}`.
- Analyze differences in:
- Logic (joins, filters, grouping, NULL handling, DISTINCT, window functions)
- Result set shape (columns, row counts, duplicates)
- Edge cases (NULLs, empty sets, date boundaries, join cardinality)
- Performance characteristics (sargability, indexes, join order risks, sorts, scans)

**Constraints**
- Assume both queries target the same SQL dialect unless the text indicates otherwise; default dialect is
`{{target_dialect}}`.
- Do not assume schema details beyond what is implied in the queries; note uncertainties as assumptions.
- If you cannot prove equivalence, state what would be required to prove it (keys, constraints, data
distributions).

**Response**
- Provide, in order:
1) Key differences (bullets)
2) Equivalence assessment: “Equivalent”, “Not equivalent”, or “Cannot determine” + why
3) Example scenarios where results diverge (if any)
4) Performance/optimization notes (bullets)
5) Suggested “best” version (optional) with rationale, if one is clearly preferable

**Query A**
```sql
{{query_a}}

**Query B**
```sql
{{query_b}}
```</Text>
        <Placeholders>
            <Placeholder name="target_dialect" editable="true"/>
            <Placeholder name="query_a" editable="true" rich="true"/>
            <Placeholder name="query_b" editable="true" rich="true"/>
        </Placeholders>
        <Metadata>
            <Category>Analyze</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt1</Id>
        <Title>Explain table in plain language</Title>
        <Description>Explains what the table likely represents and what each column likely means</Description>
        <Text>**Role**
You are a Business Analyst.

**Task**
- Explain the purpose and content of this database table in plain, non-technical English.
- Infer what the table represents and what a single row means (grain).
- Call out likely identifiers, dates, amounts, statuses, and any suspicious/unclear columns.

**Constraints**
- Base your reasoning only on the provided table name and column names/types.
- Do not invent extra columns/tables.
- If something is uncertain, state assumptions explicitly and keep them conservative.

**Response**
- Provide, in order:
1) 1 paragraph plain-language summary
2) Bullet list: what each column likely means
3) 5 example business questions this table can answer

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="dialect"/>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Analyze</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt2</Id>
        <Title>Generate GROUP BY aggregation query</Title>
        <Description>Creates 3 useful aggregation queries (single-table) based on the columns</Description>
        <Text>**Role**
You are an expert SQL developer.

**Task**
- Create 3 useful `GROUP BY` aggregation queries for the given table using SQL dialect `{{dialect}}`.
- Each query must answer a practical business question.

**Constraints**
- Use only the provided table and columns (no joins).
- Quote identifiers using the dialect’s conventions (for Microsoft Access, use brackets like `[Order Date]`).
- If date bucketing is needed, use dialect-appropriate expressions.
- If the table lacks obvious measure/dimension columns, make the best effort and state assumptions.

**Response**
- For each query, provide:
1) The business question it answers (1 sentence)
2) Final SQL only (single code block)

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="dialect"/>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt3</Id>
        <Title>Generate INSERT test data</Title>
        <Description>Generates 10 realistic INSERT statements for the table</Description>
        <Text>**Role**
You are an expert SQL developer.

**Task**
- Generate realistic test data for this table.
- Return 10 `INSERT` statements in SQL dialect `{{dialect}}`.

**Constraints**
- Use only the provided columns.
- Keep values internally consistent (e.g., statuses, amounts, dates).
- If there is an AutoNumber/identity key, omit it from `INSERT`.
- Use dialect-friendly literals (for Microsoft Access: single quotes for text, `#...#` for dates).

**Response**
- Output only the 10 `INSERT` statements (no prose).

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="dialect"/>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt4</Id>
        <Title>Propose data validation rules</Title>
        <Description>Suggests practical column- and table-level validation/constraint rules</Description>
        <Text>**Role**
You are a database designer.

**Task**
- Propose practical data validation rules and constraints for this table.

**Constraints**
- Include: required/optional, allowed ranges, formats, uniqueness, cross-field rules, and referential integrity assumptions.
- Prefer rules implementable in the target environment for dialect `{{dialect}}` (e.g., Access field validation rules, input masks, indexes, relationships).
- Do not invent extra columns/tables; if a rule depends on missing context, state assumptions.

**Response**
- Output a concise list grouped by column, plus any table-level rules.

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="dialect"/>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Analyze</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt5</Id>
        <Title>Generate data model class (Python)</Title>
        <Description>Creates a Python @dataclass model from the table columns</Description>
        <Text>**Role**
You are a software engineer.

**Task**
- Generate a Python data model for this table.
- Use a `@dataclass` with type hints.
- Choose reasonable Python types based on column names/types.

**Constraints**
- Use `Optional[...]` where appropriate (nullable/unknown).
- Keep names readable (snake_case for fields is fine).
- Do not add fields that are not in the table.
- If a type is unclear, pick the safest general type and add a short inline comment.

**Response**
- Output only the Python code.

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt6</Id>
        <Title>Generate data model class (Java)</Title>
        <Description>Creates a Java POJO model from the table columns</Description>
        <Text>**Role**
You are a software engineer.

**Task**
- Generate a Java POJO data model for this table.
- Include fields and getters/setters.
- Choose sensible types (e.g., `String`, `Integer/Long`, `BigDecimal`, `LocalDate/LocalDateTime`, `Boolean`) based on column names/types.

**Constraints**
- Use boxed types (`Integer`, `Long`, etc.) when nulls are plausible.
- Do not add fields that are not in the table.
- If a type is unclear, use `String` and add a short comment.

**Response**
- Output only the Java code.

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt7</Id>
        <Title>Generate data model class (C#)</Title>
        <Description>Creates a C# model class from the table columns</Description>
        <Text>**Role**
You are a software engineer.

**Task**
- Generate a C# data model class for this table.
- Use properties with sensible .NET types based on column names/types.

**Constraints**
- Use nullable types where appropriate (`int?`, `long?`, `decimal?`, `DateTime?`, `bool?`).
- Do not add properties not represented by the table.
- If a type is unclear, default to `string` and add a short comment.

**Response**
- Output only the C# code.

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt8</Id>
        <Title>Create REST API endpoints specification</Title>
        <Description>Drafts CRUD endpoints, filtering/pagination, validation errors, and example payloads</Description>
        <Text>**Role**
You are a backend architect.

**Task**
- Create a specification for HTTP REST API endpoints for this table/entity.
- Include CRUD endpoints, filtering/sorting, pagination, common validation errors, and example request/response JSON.

**Constraints**
- If a primary key is not obvious, propose one and state assumptions.
- Use only provided columns; do not invent extra attributes.
- Keep the spec practical for implementation (clear paths, fields, and behaviors).

**Response**
- Provide, in order:
1) Entity assumptions (PK, key fields) (bullets)
2) Endpoints list (method + path + purpose) (bullets)
3) Filtering/sorting/pagination conventions
4) Validation error patterns (bullets)
5) Example JSON for: create request, update request, single response, list response

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Generate</Category>
        </Metadata>
    </Prompt>

    <Prompt type="TablePrompt">
        <Id>TablePrompt9</Id>
        <Title>Suggest visualizations for the data</Title>
        <Description>Suggests charts/KPIs, required fields, grain, and business questions</Description>
        <Text>**Role**
You are a data analyst.

**Task**
- Suggest useful visualizations and KPIs for this table.

**Constraints**
- Base suggestions only on the provided columns.
- For each suggestion, name the fields needed and how to group (including time grain if relevant).
- If key columns (date/measure/category) are missing, state what would be needed and suggest alternatives.

**Response**
- Provide a list where each item includes:
- Chart/KPI name
- Chart type
- Required fields
- Grouping/time grain
- Business question it answers

**Table Dialect**
`{{dialect}}`

**Table**
`{{table_name}}`

**Columns**
```text
{{columns_with_types}}
```</Text>
        <Placeholders>
            <Placeholder name="table_name"/>
            <Placeholder name="columns_with_types"/>
        </Placeholders>
        <Metadata>
            <Category>Analyze</Category>
        </Metadata>
    </Prompt>

</Prompts>
